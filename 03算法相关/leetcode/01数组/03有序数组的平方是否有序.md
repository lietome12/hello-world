### 有序数组的平方

#### 题目链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array/

#### 题目描述

给你一个按 **非递减顺序** 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

**示例 1**： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

**示例 2**： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]

#### 思路

**暴力排序**：先将每个数平方，再排序

**双指针1**：以第一个大于0的数为界，该数下标为 left，right = left + 1；若 nums 全为正数 left = 0，right = 1；若 nums 全为负数，left = nums.length - 1；

循环条件：left >= 0 || right < nums.length

循环内容：if(left < 0) 将 nums[right]复制到新数组中，right++；if(right >= nums.length) nums[left]复制到新数组中，left--; 判断 nums[left] 和 nums[right] 的大小，小的放到新数组中，对应下标加加或减减。

**双指针2**：定义两个指针 left = 0、right = nums.length - 1，比较 nums[left] 和 nums[right] 的平方值的大小，将最大的值放到新数组的最末端(最大值不是在最左就是在最右)，left 或 right 指针向里移动；直到新数组填满数据。

#### 代码

```
双指针2
public int[] sortedSquares(int[] nums) {
	int left = 0, right = nums.length - 1, k = right;
	int[] result = new int[nums.length];
	while(k >= 0) {// 或 left <= right
		if(nums[left] * nums[left] >= nums[right] * nums[right]) {
			result[k--] = nums[left] * nums[left];
			left++;
		} else {
			result[k--] = nums[right] * nums[right];
			right--;
		}
	}
	return result;
}
```





