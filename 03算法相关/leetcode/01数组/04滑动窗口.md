### 长度最小的子数组

#### 题目链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum/

#### 题目描述

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足**其和 ≥ s **的长度最小的 **连续** 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

**示例**：输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

#### 思路

**滑动窗口**：

定义两个指针，分别是 子数组的开始指针 start，子数组的尾指针 end。设定和为 sum。

遍历数组 nums，移动尾指针end，sum += nums[end]；

当 sum >= s时，移动头指针 start，来确定最小的子数组。

#### 代码

```
public int minSubArrayLen(int[] nums, int s) {
	int start = 0, end = 0;// 起始位置，结束位置
	int subLength = 0;// 滑动窗口的长度
	int sum = 0;// 滑动窗口移动之和
	int result = Integer.MAX_VALUE;
	for(;end < nums.length; end++) {
		sum += nums[end];
		// 如果 sum >= s,通过移动 start 指针来比较序列是否符合
		while(sum >= s) {
			/** 为subLength 和 result 赋值，是否需要在 sum == s 的时候处理 */
			/** 不需要处理，条件是 其和>=s 而不是=s */
			subLength = (end - start + 1);
			result = result < subLength ? result : subLength;
			sum -= nums[start++];
		}
	}
	return result == Integer.MAX_VALUE ? 0 : result;
}
```

#### 相关题目

- [904.水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)

```
public class Solution {
	public static int totalFruit(int[] fruits) {
        int ans = 0, i = 0;
        Counter count = new Counter();
        for (int j = 0; j < fruits.length; ++j) {
            count.add(fruits[j], 1);
            while (count.size() >= 3) {
                count.add(fruits[i], -1);
                if (count.get(fruits[i]) == 0)
                    count.remove(fruits[i]);
                i++;
            }

            ans = Math.max(ans, j - i + 1);
        }
        return ans;
    }
}

class Counter extends HashMap<Integer, Integer> {

    public Integer get(Integer key) {
        return containsKey(key) ? super.get(key) : 0;
    }

    public void add(int key, int val) {
        put(key, get(key) + val);
    }

}
```

  

- [76.最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

