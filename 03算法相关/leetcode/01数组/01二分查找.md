## 二分查找

#### 题目链接：https://leetcode-cn.com/problems/binary-search/

#### 题目描述

给定一个 n 个元素有序的整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在则返回下标，否则返回 -1。

**示例**1

```
输入：nums = [-1,0,3,5,9,12], target = 9
输出：4
解释：9 出现在 nums 中，并且下标为 4
```

**示例2**

```
输入：nums = [-1,0,3,5,9,12], target = 2
输出：-1
解释：2 不存在 nums 中因此返回 -1
```

提示：

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。

#### 解题思路

该题的前提是数组为**有序数组**，同时题目还强调数组中**无重复元素**。如果有重复元素，使用二分查找返回的元素可能不是唯一的，有序和不重复都是二分查找的前提条件。

写二分法，区间的定义一般分为两种，左闭右闭[left, right]，左闭右开[left, right)。

**第一种写法**

第一种写法，target 是在一个左闭右闭的区间中

* while(left <= right) ，需要使用 <= ，left == right有意义

* if(nums[middle] > target) 时，right需要赋值为 middle - 1。因为 nums[middle] != target

  -1 0 3 5 9 12 left = 0, right = 5, middle = 2

  nums[middle] = 3，target = 9，nums[middle] < target；left = 5

  nums[middle] = 3，target = 2，nums[middle] > target；right = 0

具体代码

```
public Class Solution {
	/** 在指定数组中查找目标target */
	public int search(int[] nums, int target) {
		int left = 0;
		int right = nums.length - 1;
		while(left <= right) {
			// 等同于 middle = (left + right) / 2，但是为了防止溢出
			int middle = left + ((right - left) >> 1);
			if(nums[middle] > target) {
				// target 在左边
				right = middle - 1;
			} else if(nums[middle] < target) {
				// target 在右边
				left = middle + 1;
			} else {
				// target 等于 middle
				return middle;
			}
		}
		// 未找到
		return -1;
	}
}
```

**第二种写法**

第一种写法，target 是在一个左闭右开的区间中

* while(left < right) ，left 不可能等于 right

* if(nums[middle] > target) 时，right需要赋值为 middle。而nums[middle] < targe 时，需要寻找右区间，right = middle。

  -1 0 3 5 9 12 left = 0, right = 5, middle = 2

  nums[middle] = 3，target = 9，nums[middle] < target；left = 5

  nums[middle] = 3，target = 2，nums[middle] > target；right = 3(因为左闭右开，target != nums[right])

具体代码

```
public Class Solution {
	/** 在指定数组中查找目标target */
	public int search(int[] nums, int target) {
		int left = 0;
		int right = nums.length;
		while(left < right) {
			int middle = left + ((right - left) >> 1);
			if(nums[middle] > target) {
				// target 在左边
				right = middle;
			} else if(nums[middle] < target) {
				// target 在右边
				left = middle + 1;
			} else {
				// target 等于 middle
				return middle;
			}
		}
		// 未找到
		return -1;
	}
}
```



## 相关题目

35.搜索插入位置

34.在排序数组中查找元素的第一个和最后一个位置

69.x 的平方根

367.有效的完全平方数

2021/06/28完成









